<div>
    <header-menu></header-menu>
    <div class="container">
        <h1>Contact</h1>
        <p>
            Feel free to send me any suggestions and feedback on how to improve the platform
            to <a href="mailto:jordiboschbosch@hotmail.com">jordiboschbosch@hotmail.com</a>. They would
            mean a lot :)
        </p>
        <h1>Description about myself and the project</h1>
        <p>I am Jordi from Barcelona :) Another software developer in this beatiful world. On beginning of this February I started realizing I
            wanted to build something completely from scratch. Since I was doing a master in statistics and I had to do my final thesis, I thought mixing this two
            worlds would be a good idea. I would both design a useful statistics tool and a part from that I would get to touch all the steps involved in the building of a software
            product and gain a deeper knowledge in the process about how all the pieces in the frontend, backend, cloud interact as well as a different
            way to face problems.
        </p>
        <p>
            Starting your own project has many benefits and downsides.
                <li>First of all you will see in prime time how technical debt follows you ;)</li>
                <li>You can decide how to work, as well which tasks you want to prioritize. Is that good? Well a priori it seems more fun ;)<br>
                    On the long term this may have some downsides like not exploring some new ideas coming from a more
                    experienced developer or not doing enough unit testing since it is not the most exciting part.
                </li>
        </p>
        <p>I have always loved tackling big problems with a logical minded perspective. <br><br> But, first of all, what is the logical minded perspective?
            This is quite personal, but I like to think it is solving aproblem using the scientific method.
            We formulate an hypothesis with a possible path for the solution. We try to implement this solution and see if
            the results we were expecting from our hypothesis verify or not. <br>If they do, probelm solved! If they don't, let's
            try again with another solution. It is important not to fall into rabbit holes and all the times question what are you
            trying to achieve, how we want to do it and what are the results we are expecting.<br>
            My boss used to say that if you solve a bug but don't know how (copy/paste from StackOverflow for example) you have not
            solved it (and I could not agree more!). <br>Same applies for the solution of a problem. We (as engineers) should be able to explain exactly why our
            solution works and all the steps involved. This is the only way to keep growing and learning more.<br><br> Don't forget that
            <a href="https://www.maxmarchione.com/post/compounding-knowledge#:~:text=Compounding%20Knowledge%20Explained&text=If%20two%20people%20read%20the,to%20a%20larger%20knowledge%20base.">knowledge compounds!</a>
            That is you will do way better the next time if you understood exactly the reasons/steps behind your solution.
        </p>
        <h3>Limitations</h3>
        <p>After a month working on this project I realized that I could not handle everything. People have different aptitudes, skills and ways of seeing the same problem.
            This is one of the reasons companies <a href="https://www.entrepreneur.com/article/338663">should have diversity on their teams!</a> Both gender, age,
            ethnic diversity and way more. Each person, coming from a different background / life experience / environment will provide a different point of view.
            Different solutions that you would not even come across since you are clearly biased by your own experiences.<br>
            For example, I am not extremely good with designing UX/UI interfaces. I tryied to do the original mockups for the platform and
            after some time I was not still happy with the solution. I was lacking this creative, intuitive way some painters, desingers have structured their
            minds in order to create beautiful layouts.<br><br>
            It was at this point where I realized that some help would be extremely appreciated. I contacted my
            brother (which is also a Software Developer! and asked him some help). He helped a lot in the UX part and made some tweaks over my original mockups
            that made the UX way more beautiful.
        </p>
        <h3>Disclaimer</h3>
        <p>Our website does not store any data from the user. Not even the data of the experiments.
            When a user enters the data, we send it to our servers, we compute the results of the statistics test,
            we return the results, but we never save them in any place. <br>
            Thus, feel free to use the platform even if your results are non-public.
        </p>

        <h1>Public Open Roadmap</h1>
        <p>First of all, why should this be public? Actually there is no need. Almost nobody will care or even matter if it is. But... I've always loved transparency over things. Being able to dive deep into
            the insights of how things work and how they were built. That's why I thought that if sharing the steps of building a platform by yourself would help somebody that wants to do the same, this would be super
        useful. Most of the times I feel that a big challenge is just a sequence of small steps and the difficulty only lies into knowing how to divide the big challenge.</p>
        <p>This is extremely related to the difference between complex and complicated. For me, something complex is just something that needs lots of pieces/components but each step involved
            in the solution is not hard to understand, whereas something complicated at some point has a very hard to process/understand step.</p>
        <p>Thus, and since building up your platform is complex but not complicated, I feel that being able to see all tiny steps involved can provide huge value. I hope you find it useful :)</p>
        <p>So enough for presentations! Starting your own project is always tough at the beginning. Hereby I will share all the problems that I have had building it as well as a separations of tasks that
            by weeks and problems I have faced.</p>
                <h2>Stack used</h2>
                <li><strong>Angular for the frontend.</strong> Angular is a JS framework that
                    helps us abstract different features (routings inside the platform, reuse components) and many more.
                    This was not explicitly needed. You could just go with plain HTML, CSS and Vanilla JS.
                    But if you happen to know a framework, you can use it and it will speed up lots of processes.
                    In my case, I wanted to use a framework to reuse components all over the platform. Both React and Vue would
                    also have been really useful. Just make sure you choose one that you are already comfortable with
                    or one that has really good documentation. <a href="https://www.reddit.com/r/webdev/comments/atgke2/react_vs_vanilla_js_when_to_use_each_of_them/">Check here</a> for more info
                </li><br>
                <li>
                <strong>Python for the backend. </strong>This choice was tricky. I had almost no experience with Python. I have done all backends in NodeJS. Since
                    this platform has to deal with statistics algorithms, Python or R would simplify a lot some processes since
                    the statistics comunity is heavy reliant into both of them. <br> The fact that I ended up chosing Python over R was because lots
                    of backends are made with Python and thus, it would be way easier to set up a backend and comunicate with
                    the frontend better than using R.
                </li><br>
            <li>
                <strong>Google Cloud as my cloud provider and Firebase as my database.</strong> I would like to move my stack to DynamoDB and AWS but since I have
                work experience with the former one, I prefer to use GCloud. I would like to move at some point to move my cloud vendor to AWS since I deeply think
                up to this moment it is way more complete and has more features. <br> Since at this point I don't care THAT much about complex features
                and both platforms will be useful, I will go with Google Cloud since it will be faster for me.

                I want to be prepared for high traffic and scalability, that's why, deciding exactly which servers/containers/structures exactly inside Google Cloud
                will be done later.
            </li>
        <br>
            <li>
            <strong>
            Hosting: Firebase
            </strong>
            </li>
            <br>
            <li>
            <strong>
                DNS provider: Google Domains
            </strong>
            </li>
            <h2>Project considerations</h2>
        <p>Some initial considerations regarding this project should be made</p>
        <li>This project aims for helping people do statistics, simplifying some tedius calculations processes.</li><br>
    <li>I want this to have formality over usability. If at some point I feel like I am adding new features just
        to have a bigger platform, I will have missed my goal. <a href="https://www.minimalismmadesimple.com/home/17-reasons-why-less-is-more/">Less is More</a>
        I want this to be a place where somebody that wants to learn, can learn, not just lots of calculators that do
        the computations without explanation.
    </li> <br>
    <li>
        I want to do things fast, simple and working. If something works, it will be kept this way. No over complexities,
        no what ifs, I want to follow the principles of Agile and keep iterating and obtaining feedback. Value will be
        defined by the users, not by mysefl.
    </li> <br>
    <li>
        This project will <strong>not have unit testing</strong>. I know my boss would kill me if he saw that but, I want to do it really fast,
        as an <a href="https://www.whatisanindiemaker.com/">indie maker</a>, and it will be just myself dealing with the code. <strong>Warning:</strong>This is a must NOT do in
    software development.<br> All code should be tested, specially if you want to build robust, mantainable, shared code.<br>
    Since in this case, it will just be myself and the time to develop this platform is really limited, I have taken the permission to not follow best software practices. Lets see
    how it goes ðŸ˜³.
    </li> <br>
    <h2>Weekly 1 goals</h2>
    <li>Do a competitive study on the comptence</li>
    <li>Diferentiate my project from the competence.
        Which tools could be improved? How would I do it better?
    </li>
    <h2>Weekly 2 goals</h2>
    <li>Build Figma desing(I have really bad eye for UX). Luckily my brother does not, and he helped me with that part.</li>
    <li>Tune the color palette that I will use all over the platform</li>
    <h2>Weekly 3 goals</h2>
    <li>Decide the name of the platform</li>
    <li>Start building frontend</li>
    <li>Decide module structure, initial components needed.</li>
    <h2>Weekly 4 goals</h2>
    <li>
        Have extremely basic mockup working (with routing working, components created and properly styled)<br>
        <img width="50%" [src]="'assets/img/initial_mockup.png'">
    </li>
    <h2>Weekly 5 goals</h2>
    <li>Up to this point, I face the first technical challenge. I have tried to use ChartJS for client side charts. Some problems arise with this.
        First of all, it introduces a lot of communication between the backend results of the statistics tests and the frontend library. This turns into
        multiple parameters returned by the backend need to be parsed and then introduced into the frontend charting library.
        Secondly, Python is way more prepared to chart statistics graphs. I could generate the output on the backend and send the results (image included). In the backend, charting the results with Python is way more immediate and provides better results
    to the user. Thats why I decided to go with this second option. We should be aware that comes with a tradeoff of more bandwidth used in client side to be able
    to receive the image from the backend<br>
    </li><br>,
    <li>Cloud environment preparation in order to be able to deploy servers, databases and hostings.
        As previously mentioned I chose Firebase and Gcloud. Setting up the initial steps is not hard.
    Follow this link (for Firebase) configuration. Firebase offers a very powerful CLI that works really good and makes developer lives way easier. <br>
    The first step to do was to using  <a href="https://firebase.google.com/docs/hosting">Firebase as a hosting.</a> We want to have a mockup URL(with the .firebaseapp.com) where we can deploy our code and show
    it to other people. To do so, we need to upload all the static files that firebase need to return when the URL will be called. As I said, follow the steps in
    the guide and you will be able to deploy it.
    </li><br>
    <img width="50%" [src]="'assets/img/firebase_deploy.png'">
    <li>Set up a Python server on Google Cloud. As a starting point I will make it work using google cloud functions(lambdas in AWS). This are perfect for
        scalability and just using what you need and not caring much about the infraestructure. Cloud functions comes with the tradeoff of cold starts (that is,
    the function experiences a signficant relay the first time it is called in a while(5-15) minutes more or less. This is no problem if you have enough traffic,
    otherwise you end up loosing 1-1.5 seconds which are really valuable for user retention. Another option to explore(when looking at user metrics) would be to move
    it into Cloud Run (which resembles way more a traditional server) and can handle thousands of calls at the same time.</li>
    <li>To set up a cloud function in Python we have used gcloud CLI. We already deployed our frontend into the hosting using Firebase CLI, but,
        in this case, we will need gcloud CLI, since Firebase CLI is only prepared for dealying with deployments of functions written in TS/JS.
        Just install <a href="https://cloud.google.com/sdk/docs/install">gcloud CLI</a> and deploy them using the commands staten <a href="https://cloud.google.com/functions/docs/concepts/python-runtime">here</a>
    </li>
    <li>Choosing which Python web framework (Django or Flask)</li>
    <li>Once we know we will be using Flask, we will start trying to deploy a first Hello World function.
        Once we have achieved that, we will call this mock function from the frontend using http client library in Angular.
        It is important to go step by step making sure the previous one works before moving to the next one. This way, we can
        guarantee we are building a solution that will end up working.
    </li>
    <br>
    <h2>Weekly 7 goals</h2>
    <li>This week was basically devoted to learn the basics of Flask and how to set up a backend with Python in this framework.
        Flask is a framework that helps us build a straightforward webserver in an easy and intuitive way. The integration with it, even
        for non-Python developers is really easy.<br><br>
        That does not mean you won't encounter different kind of errors. It has taken me a while and some mistakes to correctly do the set up.
        I will share here some of the mistakes I have faced. Remember to face mistakes as oportunities to learn more and not let them take down
        your self esteem. It is part of the developers job and you will face lots of them in your career, so, better be prepared and with a
        positive mindset.
        <ul>
            <li><h2>1. CORS.</h2> The most classic one. You will always have this error when setting up a web server and if you
                don't receive it at first, either it is not the first time you set up a web server or you are in a big trouble
            <img width="50%" [src]="'assets/img/cors.png'"><br>
        You can read a little bit about what CORS policies are, why they are needed, and how to set them up <a href="https://web.dev/cross-origin-resource-sharing/">here</a>.
            </li>
            <li>
                <h2>2. Multithreading</h2>
                <img width="50%" [src]="'assets/img/matplotlib_thread.png'"><br>
                Honestly, this one was way more tricky and harder to debug, since CORS is an extremely common issue and is very well documented
                but not this one.

                *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '+[NSUndoManager(NSInternal) _endTopLevelGroupings] is only safe to invoke on the main thread.'

                Basically we were executing code in multiple threads in our backend. This is due to the nature of matplotlib GUI.
                When we are executing scripts in Jupyter for example and we want to generate a plot, this set of plot instructions are
                executed in a different thread. <br>
                Multithreading programming allows to speed things. If we have 2 subtasks (A and B) and each task does not need the other, we can
                execute them in different computer processing unit and speed the process. The problem is if they share 'state', like in this case.
                Here the 'state' is a common graph in which the two subtasks are changing things. To solve this issue, I noticed that
                there was no need to plot the graph in the backend(Our backend will be in a Cloud in Belgium), the only thing we need
                is to be able to 'save' the graph, not 'render' it on the backend.<br>
                Once I changed this, I was able to correclty generate, save and send the image from the backend to the frontend.
            </li>
            <li>Many other little mistakes have appeared in the process, I just showed two of them as examples</li>
        </ul>
    </li>
    <li>
        Continuing with goals this week. I would like to parse ANOVA input and generate the correspondig graphics and results
        in the frontend. I have been able to correclty connect and send images from both places right now so I believe it is doable
        to have it all set for two days from now.
    </li>
    <li>Finally could set up all servers in production working with image transfer!
        <img width="50%" [src]="'assets/img/image_frontend_production.jpg'"><br>
        It took way less than I have expected. As we can see the project does the
        call from an already public DNS to the backend in Google Cloud functions.
    </li>
    <li>Next step: Generating an image that actually reads the values from the frontend
        and generates the correspondig ANOVA for
        <ul>
            <li>Up to this point I faced the problem of just generating a simulated
                image with matplotlib in the backend and being able to send it up to the front.
                Right now we generate the correct and expected images. Some considerations should be taken.
                First of all, I don't know beforehand how many treatment groups the user
                will select. That complicates a little bit things, since I am not able
                to state it when I create when the components are rendered in the frontend.
                To handle this scenarios we will use dynamic forms (See angular documentation).
                This dynamic forms will help us make sure all the data in the user side is validated
                and provide the user with some mechanism in order for they to know if some
                value is not correctly formated, or a comma is missing, just to prevent a future
                error to happen.<br>
            </li>
        </ul>
    </li>
    <li>First mistakes (CORS). We have to investigate how to set up an origin for the cors policy. CORS is a classic error you
    will have when setting and calling a new server. Read more about what is the problem and what should be the solution .

    <h2>Weekly 8 goals</h2>
    <p>Finally managed to return multiple images to the frontend using same endpoint. It has taken me a while more than expected because lots of things
        needed to be taken into account.
    </p>
    <li>First Approach: Lets try to return multiple images using the same Http Request! It should be really easy. Reality turned out to be way more complicated.
        There is no MIME type for returning multiple images, and thus it can not be done. Maybe there is some kind of special tweak that allows it but after digging
        many hours could not achieve it.
    </li>
    <li>Second Approach: Build a zip on the backend, send it using the correct MIME type to the frontend. Then unzip it on client side and display all images.
        This can be done using standard JS library (jsZIP) but comes with 2 tradeoffs. Not all browsers support this solution. It requires lot of CPU on client side.
    </li>

    <li>Third Approach: Call multiple times the same endpoint from the frontend with different parameters specifying which image you want to be returned
        Although this was not my primary option, it turned out to be the easiest and quickest to apply. Once this option is selected we face another choice:
        What should we return to the frontend? I only need the image to be rendered in an [img] HTML tag. We have two options.
        <ul>
        <li>
        Return a path to the frontend. Frontend will make an API call to the service where we host our image.
            Disadvantage: My backend should return a path to the front and upload the image to a host (easiest option would be S3 in AWS or Storage in Firebase). More work.
            Advantage: I could put CloudFront CDN and serve the static S3 files from there. This would make it really fast worlwide and have the huge benefits of
            caching.
        </li>
        <li>
        Return directly the binary to the frontend.
            Advantage: Really fast to implement.
            Disadvantage: No caching. Slower.
        As with all the decisions I have taken up to the moment, I choose the easiest way to implement, with the goal of improvimg
        </li>
    </ul>
    </li>

    <h2>Weekly 9 goals</h2>
    Finally completed some important tasks:
    <li>Added all latex explanation for ANOVA: We tryied to be mathematically formal and make sure user would understand the underlying concepts </li>
    <h2>Weekly 10 goals</h2>
    <li>Added multiple images return</li>
    <h2>Weekly 11 goals</h2>
    <li>Added random numbers generated at the beginning in the textareas. It makes the user understand that values should be separated by commas and avoid
        future errors.
        Some big problem coming! I knew it would come, but I would not expect to notice it that early.
        State is becoming bigger and lots of components are talking to themselves independently. This is a
        common frontend problem. Solution? Taking the Redux pill.
    </li>
    <h2>Weekly 19 goals</h2>
    I missed adding all my goals for the previous weeks :(. Sorry about that. Over this 8 weeks
    I have:
    <li>Added all other hypothesis testing calculators. Once the ANOVA was finisished it
        was way faster to create the other calculators. I could reuse many components and
        reduce a lot the amount of code (and so time!) needed.
    </li>
    <li>Added all other descriptive statistics calculators</li>
    <li>Added the theoretical explanations behind the tests. Right now, there
        is a button "View theoretical explanation", that renders a PDF with an explanation
        of what is behind the tests. This will allow more advanced/technical students
        to dive deep into the inner workings of the method as well as using the results.
    </li>
    <li>My master thesis teacher suggested adding the option of uploading
        CSV instead of copy-pasting the values. I though it was a great idea,
        specially for cases where you have an extreme amount of values. Added this
        feature some weeks ago.
    </li>
        <div class="anova-images">
            <img width="45%" [src]="'assets/img/anova-csv.png'">
            <img width="45%" [src]="'assets/img/anova-explanation.png'">
        </div>
        <li>Bought a domain name and put the website under that domain.
            All over the year I've liked the domain name <a href="http://www.statisticsworld.com/">statisticsworld.com</a>
            but I forgot to check if it was available / I looked at it some months ago
            and though no one would buy it... and...it is not :( <br>
            I contacted the owner and they asked me for 1155 USD ðŸ˜…ðŸ˜…ðŸ˜…ðŸ˜…
        That's why I ended up buying <a href="http://www.stats-world.com/">stats-world.com</a> for 12EUR
    </li>
    Some important things about buying a domain:
    <li>It should be easy to remember</li>
    <li>It would be nice to have SSL certificates it it. (that is the https encrypted).
        This is extremely important in the case you are dealing with sensitive information
        (e.g passwords and credit card numbers). Basically, if you don't have it, an attacker
        can steal all your client sensitive data. <br>
        A part from that, browsers sometimes pop up a warning to the user that they might
        get into a dangerous website and for sure don't want that
    </li>
    Once the domain is bought some things need to happen. When a user enters a website URL in the searcher,
    there are some DNS resolutions in order to get the IP of the hosting files and be able to download
    and render them.<br>
    We should add a record (A type record), with the IP of our hosting. This way, DNS resolutions will
    be able to find it and serve the end user.<br><br>
    Will leave it like this for the moment. Website is done and everything is working more or less 'properly'.
    Lets leave it here.<br>
    </div>
</div>